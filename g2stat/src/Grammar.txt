//----------------------------
//----------------------------
//------- Assignments --------
//----------------------------
//----------------------------

ALPHABET EToken;
STARTSYMBOL START;


//----------------------------
//----------------------------
//--------- C Enums ----------
//----------------------------
//----------------------------

enum EToken
		{
			TOKEN_ILLEGAL,
			TOKEN_END,
			TOKEN_WHITESPACE,
			TOKEN_LINEFEED,
			TOKEN_SINGLELINECOMMENT,
			TOKEN_MULTILINECOMMENT,
			TOKEN_IDENTIFIER,
			TOKEN_INTNUMBER,
			TOKEN_FLOATNUMBER,
			TOKEN_LITERAL,
			//keywords
			TOKEN_CLASS,
			TOKEN_CONST,
			TOKEN_ELSE,
			TOKEN_FLOAT,
			TOKEN_FUNC,
			TOKEN_IF,
			TOKEN_INSTANCE,
			TOKEN_INT,
			TOKEN_PROTOTYPE,
			TOKEN_RETURN,
			TOKEN_STRING,
			TOKEN_VAR,
			TOKEN_VOID,
			//operators
			TOKEN_ASSIGNMENT,
			TOKEN_BITWISEAND,
			TOKEN_BITWISEOR,
			TOKEN_BRACECLOSE,
			TOKEN_BRACEOPEN,
			TOKEN_COMMA,
			TOKEN_DIVIDE,
			TOKEN_DOT,
			TOKEN_EQUALS,
			TOKEN_GREATEROREQUAL,
			TOKEN_GREATERTHAN,
			TOKEN_LESSOREQUAL,
			TOKEN_LESSTHAN,
			TOKEN_LOGICALAND,
			TOKEN_LOGICALOR,
			TOKEN_MINUS,
			TOKEN_MINUSASSIGN,
			TOKEN_MULTIPLY,
			TOKEN_NOT,
			TOKEN_NOTEQUALS,
			TOKEN_PARENCLOSE,
			TOKEN_PARENOPEN,
			TOKEN_PLUS,
			TOKEN_PLUSASSIGN,
			TOKEN_SEMICOLON,
			TOKEN_SHIFTLEFT,
			TOKEN_SQUAREDBRACKETCLOSE,
			TOKEN_SQUAREDBRACKETOPEN,
		};


//----------------------------
//----------------------------
//-- Lexer Production Rules --
//----------------------------
//----------------------------

'[ \t\r\f]+' -> TOKEN_WHITESPACE;

'\n' -> TOKEN_LINEFEED;

'//[^\r\n]*' -> TOKEN_SINGLELINECOMMENT;

'/\*.*?\*/' -> TOKEN_MULTILINECOMMENT;

'[0-9]+' -> TOKEN_INTNUMBER;

'(0|([1-9][0-9]*))\.[0-9]+' -> TOKEN_FLOATNUMBER;

'"[^"]*"' -> TOKEN_LITERAL;

//Keywords:
'class' CASE_INSENSITIVE -> TOKEN_CLASS;
'const' CASE_INSENSITIVE -> TOKEN_CONST;
'else' CASE_INSENSITIVE -> TOKEN_ELSE;
'float' CASE_INSENSITIVE -> TOKEN_FLOAT;
'func' CASE_INSENSITIVE -> TOKEN_FUNC;
'if' CASE_INSENSITIVE -> TOKEN_IF;
'instance' CASE_INSENSITIVE -> TOKEN_INSTANCE;
'int' CASE_INSENSITIVE -> TOKEN_INT;
'prototype' CASE_INSENSITIVE -> TOKEN_PROTOTYPE;
'return' CASE_INSENSITIVE -> TOKEN_RETURN;
'string' CASE_INSENSITIVE -> TOKEN_STRING;
'var' CASE_INSENSITIVE -> TOKEN_VAR;
'void' CASE_INSENSITIVE -> TOKEN_VOID;

//Operators:
'=' -> TOKEN_ASSIGNMENT;
'&' -> TOKEN_BITWISEAND;
'\|' -> TOKEN_BITWISEOR;
'}' -> TOKEN_BRACECLOSE;
'{' -> TOKEN_BRACEOPEN;
',' -> TOKEN_COMMA;
'/' -> TOKEN_DIVIDE;
'\.' -> TOKEN_DOT;
'==' -> TOKEN_EQUALS;
'>=' -> TOKEN_GREATEROREQUAL;
'>' -> TOKEN_GREATERTHAN;
'<=' -> TOKEN_LESSOREQUAL;
'<' -> TOKEN_LESSTHAN;
'&&' -> TOKEN_LOGICALAND;
'\|\|' -> TOKEN_LOGICALOR;
'\-' -> TOKEN_MINUS;
'\-=' -> TOKEN_MINUSASSIGN;
'\*' -> TOKEN_MULTIPLY;
'!' -> TOKEN_NOT;
'!=' -> TOKEN_NOTEQUALS;
'\)' -> TOKEN_PARENCLOSE;
'\(' -> TOKEN_PARENOPEN;
'\+' -> TOKEN_PLUS;
'\+=' -> TOKEN_PLUSASSIGN;
';' -> TOKEN_SEMICOLON;
'<<' -> TOKEN_SHIFTLEFT;
'\]' -> TOKEN_SQUAREDBRACKETCLOSE;
'\[' -> TOKEN_SQUAREDBRACKETOPEN;

//Less Priority than keywords
'[a-zA-Z_д][a-zA-Z0-9_дя]*' -> TOKEN_IDENTIFIER;



//---------------------------
//---------------------------
//--- Operator Precedence ---
//---------------------------
//---------------------------

OPPREC
LEFT TOKEN_LOGICALOR;
LEFT TOKEN_LOGICALAND;
LEFT TOKEN_EQUALS TOKEN_NOTEQUALS;
LEFT TOKEN_LESSTHAN TOKEN_LESSOREQUAL TOKEN_GREATERTHAN TOKEN_GREATEROREQUAL;
LEFT TOKEN_PLUS TOKEN_MINUS;
LEFT TOKEN_MULTIPLY TOKEN_DIVIDE;
LEFT #UNARY;
;



//---------------------------------
//---------------------------------
//---- Parser Production Rules ----
//---------------------------------
//---------------------------------

START -> GLOBALS;

GLOBALS -> ;
GLOBALS -> CONSTANT GLOBALS;
GLOBALS -> CLASS GLOBALS;
GLOBALS -> FUNCTION GLOBALS;
GLOBALS -> INSTANCE GLOBALS;
GLOBALS -> PROTOTYPE GLOBALS;
GLOBALS -> VARIABLE GLOBALS;

CONSTANT -> TOKEN_CONST TYPE TOKEN_IDENTIFIER TOKEN_ASSIGNMENT CONSTVALUE TOKEN_SEMICOLON;
//WORKED WITH CONSTVALUE INSTEAD OF ARRAYINDEX
CONSTANT -> TOKEN_CONST TYPE TOKEN_IDENTIFIER TOKEN_SQUAREDBRACKETOPEN ARRAYINDEX TOKEN_SQUAREDBRACKETCLOSE TOKEN_ASSIGNMENT TOKEN_BRACEOPEN CONSTVALUES TOKEN_BRACECLOSE TOKEN_SEMICOLON;
CLASS -> TOKEN_CLASS TOKEN_IDENTIFIER TOKEN_BRACEOPEN VARIABLES TOKEN_BRACECLOSE TOKEN_SEMICOLON;
FUNCTION -> TOKEN_FUNC RETURNVALUE TOKEN_IDENTIFIER TOKEN_PARENOPEN ARGUMENTS TOKEN_PARENCLOSE TOKEN_BRACEOPEN STATEMENTS TOKEN_BRACECLOSE TOKEN_SEMICOLON;
INSTANCE -> TOKEN_INSTANCE NAMES TOKEN_PARENOPEN TOKEN_IDENTIFIER TOKEN_PARENCLOSE TOKEN_SEMICOLON;
INSTANCE -> TOKEN_INSTANCE NAMES TOKEN_PARENOPEN TOKEN_IDENTIFIER TOKEN_PARENCLOSE TOKEN_BRACEOPEN STATEMENTS TOKEN_BRACECLOSE TOKEN_SEMICOLON;
PROTOTYPE -> TOKEN_PROTOTYPE TOKEN_IDENTIFIER TOKEN_PARENOPEN TOKEN_IDENTIFIER TOKEN_PARENCLOSE TOKEN_BRACEOPEN STATEMENTS TOKEN_BRACECLOSE TOKEN_SEMICOLON;

TYPE -> TOKEN_FLOAT;
TYPE -> TOKEN_FUNC;
TYPE -> TOKEN_INT;
TYPE -> TOKEN_STRING;
TYPE -> TOKEN_IDENTIFIER;

CONSTVALUE -> TOKEN_IDENTIFIER;
CONSTVALUE -> TOKEN_FLOATNUMBER;
CONSTVALUE -> TOKEN_INTNUMBER;
CONSTVALUE #UNARY -> TOKEN_MINUS TOKEN_INTNUMBER;
CONSTVALUE -> TOKEN_LITERAL;
CONSTVALUE -> TOKEN_PARENOPEN CONSTVALUE TOKEN_PARENCLOSE;
CONSTVALUE -> TOKEN_BRACEOPEN CONSTVALUES TOKEN_BRACECLOSE;
CONSTVALUE -> CONSTVALUE TOKEN_PLUS CONSTVALUE;
CONSTVALUE -> CONSTVALUE TOKEN_MULTIPLY CONSTVALUE;
CONSTVALUE -> CONSTVALUE TOKEN_DIVIDE CONSTVALUE;
CONSTVALUE -> CONSTVALUE TOKEN_SHIFTLEFT CONSTVALUE;
CONSTVALUE -> CONSTVALUE TOKEN_BITWISEOR CONSTVALUE;

CONSTVALUES -> CONSTVALUE;
CONSTVALUES -> CONSTVALUE TOKEN_COMMA CONSTVALUES;

VARIABLES -> ;
VARIABLES -> VARIABLE VARIABLES;

VARIABLE -> TOKEN_VAR TYPE NAMES TOKEN_SEMICOLON;
//WORKED WITH NAMES INSTEAD OF TOKEN_IDENTIFIER; CONSTVALUE INSTEAD OF ARRAYINDEX
VARIABLE -> TOKEN_VAR TYPE TOKEN_IDENTIFIER TOKEN_SQUAREDBRACKETOPEN ARRAYINDEX TOKEN_SQUAREDBRACKETCLOSE TOKEN_SEMICOLON;

NAMES -> TOKEN_IDENTIFIER;
NAMES -> TOKEN_IDENTIFIER TOKEN_COMMA NAMES;

STATEMENTS -> ;
STATEMENTS -> STATEMENT STATEMENTS;

STATEMENT -> TOKEN_VAR TYPE TOKEN_IDENTIFIER TOKEN_SEMICOLON;
STATEMENT -> LEFTVALUE TOKEN_ASSIGNMENT EXPR TOKEN_SEMICOLON;
STATEMENT -> LEFTVALUE TOKEN_MINUSASSIGN EXPR TOKEN_SEMICOLON;
STATEMENT -> LEFTVALUE TOKEN_PLUSASSIGN EXPR TOKEN_SEMICOLON;
STATEMENT -> TOKEN_IDENTIFIER TOKEN_PARENOPEN CALLARGS TOKEN_PARENCLOSE TOKEN_SEMICOLON;
STATEMENT -> TOKEN_IF EXPR TOKEN_BRACEOPEN STATEMENTS TOKEN_BRACECLOSE ELSEIFS;
STATEMENT -> TOKEN_RETURN TOKEN_SEMICOLON;
STATEMENT -> TOKEN_RETURN EXPR TOKEN_SEMICOLON;
STATEMENT -> TOKEN_IDENTIFIER TOKEN_SEMICOLON;
STATEMENT -> LEFTVALUE TOKEN_EQUALS EXPR TOKEN_SEMICOLON;

LEFTVALUE -> TOKEN_IDENTIFIER;
LEFTVALUE -> TOKEN_IDENTIFIER TOKEN_DOT TOKEN_IDENTIFIER;
//WORKED WITH EXPR INSTEAD OF ARRAYINDEX
LEFTVALUE -> TOKEN_IDENTIFIER TOKEN_DOT TOKEN_IDENTIFIER TOKEN_SQUAREDBRACKETOPEN ARRAYINDEX TOKEN_SQUAREDBRACKETCLOSE;
//WORKED WITH EXPR INSTEAD OF ARRAYINDEX
LEFTVALUE -> TOKEN_IDENTIFIER TOKEN_SQUAREDBRACKETOPEN ARRAYINDEX TOKEN_SQUAREDBRACKETCLOSE;

EXPR -> CONSTVALUE;
EXPR -> LEFTVALUE;
EXPR #UNARY -> TOKEN_NOT EXPR;
EXPR #UNARY -> TOKEN_MINUS EXPR;
EXPR #UNARY -> TOKEN_PLUS EXPR;
EXPR -> TOKEN_PARENOPEN EXPR TOKEN_PARENCLOSE;

EXPR -> EXPR TOKEN_PLUS EXPR;
EXPR -> EXPR TOKEN_MINUS EXPR;
EXPR -> EXPR TOKEN_MULTIPLY EXPR;
EXPR -> EXPR TOKEN_DIVIDE EXPR;

EXPR -> EXPR TOKEN_EQUALS EXPR;
EXPR -> EXPR TOKEN_NOTEQUALS EXPR;
EXPR -> EXPR TOKEN_LESSTHAN EXPR;
EXPR -> EXPR TOKEN_LESSOREQUAL EXPR;
EXPR -> EXPR TOKEN_GREATERTHAN EXPR;
EXPR -> EXPR TOKEN_GREATEROREQUAL EXPR;
EXPR -> EXPR TOKEN_LOGICALAND EXPR;
EXPR -> EXPR TOKEN_LOGICALOR EXPR;

EXPR -> EXPR TOKEN_BITWISEAND EXPR;
EXPR -> EXPR TOKEN_BITWISEOR EXPR;

EXPR -> TOKEN_IDENTIFIER TOKEN_PARENOPEN CALLARGS TOKEN_PARENCLOSE;

RETURNVALUE -> TOKEN_VOID;
RETURNVALUE -> TOKEN_INT;
RETURNVALUE -> TOKEN_STRING;

ARGUMENTS -> ;
ARGUMENTS -> TOKEN_VAR TYPE TOKEN_IDENTIFIER;
ARGUMENTS -> TOKEN_VAR TYPE TOKEN_IDENTIFIER TOKEN_COMMA ARGUMENTS;

CALLARGS -> ;
CALLARGS -> EXPR;
CALLARGS -> EXPR TOKEN_COMMA CALLARGS;

ELSEIFS -> ;
ELSEIFS -> TOKEN_SEMICOLON;
ELSEIFS -> TOKEN_ELSE TOKEN_BRACEOPEN STATEMENTS TOKEN_BRACECLOSE TOKEN_SEMICOLON;
ELSEIFS -> TOKEN_ELSE TOKEN_IF EXPR TOKEN_BRACEOPEN STATEMENTS TOKEN_BRACECLOSE ELSEIFS;

ARRAYINDEX -> TOKEN_INTNUMBER;
ARRAYINDEX -> TOKEN_IDENTIFIER;